#!/bin/env python3.3
#
# Copyright 2014 Peter Griess
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
#
# View portions of an OSM file.

import argparse
import collections
import contextlib
import json
import logging
import lxml.etree
import pystache
import os.path
import pprint
import shapely.geometry
import subprocess
import sys
import tempfile

# Add src/ directory to PYTHONPATH so that this can be run without the operator
# having to configure that manually
sys.path += [os.path.join(os.path.dirname(sys.argv[0]), '..', 'src')]

import crimedb.cli

class OSMParserCallbacks:
    Node = collections.namedtuple('Node', ['id', 'lon', 'lat', 'tags'])
    Way = collections.namedtuple('Way', ['id', 'nids', 'tags'])
    Relation = collections.namedtuple('Relation', ['id', 'wids', 'tags'])

    def __init__(self, nids=set(), wids=set(), rids=set()):
        self.nodes = {}
        self.ways = {}
        self.relations = {}

        self.__nids = nids
        self.__wids = wids
        self.__rids = rids
        self._tag_stack = []
        self._id_stack = []

    def start(self, tag, attrib):
        tid = int(attrib.get('id', -1))

        if tag == 'node':
            self._id_stack.append(tid)
            if tid in self.__nids:
                self.nodes[tid] = OSMParserCallbacks.Node(
                        id=tid,
                        lon=float(attrib['lon']),
                        lat=float(attrib['lat']),
                        tags={})
        elif tag == 'way':
            self._id_stack.append(tid)
            if tid in self.__wids:
                self.ways[tid] = OSMParserCallbacks.Way(
                        id=tid, nids=[], tags={})
        elif tag == 'relation':
            self._id_stack.append(tid)
            if tid in self.__rids:
                self.relations[tid] = OSMParserCallbacks.Relation(
                        id=tid, wids=[], tags={})
        elif tag == 'nd' and \
                self._tag_stack[-1] == 'way' and \
                self._id_stack[-1] in self.__wids:
            self.ways[self._id_stack[-1]].nids.append(
                    int(attrib['ref']))
        elif tag == 'member' and \
                attrib['type'] == 'way' and \
                self._tag_stack[-1] == 'relation' and \
                self._id_stack[-1] in self.__rids:
            self.relations[self._id_stack[-1]].wids.append(
                    int(attrib['ref']))
        elif tag == 'tag':
            last_tag = self._tag_stack[-1]
            last_id = self._id_stack[-1]
            if last_tag == 'node' and last_id in self.__nids:
                self.nodes[last_id].tags[attrib['k']] = attrib['v']
            elif last_tag == 'way' and last_id in self.__wids:
                self.ways[last_id].tags[attrib['k']] = attrib['v']
            elif last_tag == 'relation' and last_id in self.__rids:
                self.relations[last_id].tags[attrib['k']] = attrib['v']

        self._tag_stack.append(tag)

    def end(self, tag):
        self._tag_stack.pop()
        
        if tag in set(['node', 'way', 'relation']):
            self._id_stack.pop()

    def data(self, data):
        pass

    def comment(self, text):
        pass

    def close(self):
        pass


ap = argparse.ArgumentParser(
        usage='''
  osm-view [options] <path> <relation-id>
  osm-view [options] <path>
''',
        description='''
View a relation in an OSM data dump in a web app. This is intended as an aid
for relation selection. The first usage pattern works on .osm XML files. It
will likely take several minutes to run on large dumps. To ameliorate this, the
'-g' option can be used to save the resuting GeoJSON output to a file for later
usage. The second usage pattern works with the output of the -g option in the
first pattern. This should run much more quickly.
''',
        parents=[crimedb.cli.logging_argument_parser])
ap.add_argument('file_path', metavar='<path>',
                help='path to the file to view')
ap.add_argument('relation', metavar='<relation-id>', nargs='?',
                help='identifier for the OSM relation to view')
ap.add_argument('-g', dest='gj_output', metavar='<path>',
                default=None, help='serialize to the given GeoJSON file')

args = ap.parse_args()
crimedb.cli.process_logging_args(args)

if not args.relation:
    with open(args.file_path, 'rt', encoding='utf-8') as f:
        polygon = json.load(f)
else:
    rids = set([int(args.relation)])

    opc = OSMParserCallbacks(rids=rids)
    with open(args.file_path, 'rb') as osm_f:
        with contextlib.closing(
                lxml.etree.XMLParser(target=opc)) as xp:
            while True:
                d = osm_f.read(1024)
                if not d:
                    break
                xp.feed(d)
    relations = opc.relations
    logging.info('matched {} relations'.format(len(relations)))

    # Grab ways from the relation
    wids = set()
    for r in opc.relations.values():
        wids |= set(r.wids)
    logging.debug('looking for wids={}'.format(pprint.pformat(wids)))
    opc = OSMParserCallbacks(wids=wids)
    with open(args.file_path, 'rb') as osm_f:
        with contextlib.closing(
                lxml.etree.XMLParser(target=opc)) as xp:
            while True:
                d = osm_f.read(1024)
                if not d:
                    break
                xp.feed(d)
    ways = opc.ways
    logging.info('matched {} ways'.format(len(ways)))

    # Grab nodes from the ways
    nids = set()
    for w in opc.ways.values():
        nids |= set(w.nids)
    logging.debug('looking for nids={}'.format(pprint.pformat(nids)))
    opc = OSMParserCallbacks(nids=nids)
    with open(args.file_path, 'rb') as osm_f:
        with contextlib.closing(
                lxml.etree.XMLParser(target=opc)) as xp:
            while True:
                d = osm_f.read(1024)
                if not d:
                    break
                xp.feed(d)
    nodes = opc.nodes
    logging.info('matched {} nodes'.format(len(nodes)))

    # We only support serializing a single relation right now
    assert len(relations) == 1
    relation = next(iter(relations.values()))

    relation_nodes = []
    for wid in relation.wids:
        way_nodes = [nodes[nid] for nid in ways[wid].nids]

        # No path yet; accept first way as-is
        if not relation_nodes:
            relation_nodes += way_nodes
            continue

        # Detect if the way needs to have its order reversed
        # so that it cleanly appends/prepends to the path so far
        if way_nodes[-1] == relation_nodes[-1] or \
                way_nodes[0] == relation_nodes[0]:
            way_nodes.reverse()

        # At this point, the way should either be a clean prepend
        # or append; do it
        if way_nodes[0] == relation_nodes[-1]:
            relation_nodes += way_nodes[1:]
        else:
            assert way_nodes[-1] == relation_nodes[0]
            relation_nodes = way_nodes[:-1] + relation_nodes

    polygon = {
        'type': 'Polygon',
        'tags': relation.tags,
        'coordinates': [
            [(n.lon, n.lat) for n in relation_nodes],
        ],
    }

    if args.gj_output:
        with open(args.gj_output, 'wt', encoding='utf-8') as f:
            f.write(json.dumps(polygon))


# Now that we've got the GeoJSON polygon, construct a one-page
# webapp to view it
html_content = '''
<html>
    <head>
        <title>{{tags.name}}</title>

        <link rel="stylesheet" href="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.css"/>
        <link rel="stylesheet" href="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.0/themes/smoothness/jquery-ui.css" />

        <script src="http://cdn.leafletjs.com/leaflet-0.7.3/leaflet.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jquery/2.1.0/jquery.min.js"></script>
        <script src="http://ajax.googleapis.com/ajax/libs/jqueryui/1.11.0/jquery-ui.min.js"></script>
        <script src="http://maps.stamen.com/js/tile.stamen.js?v1.3.0"></script>

        <style type="text/css">
            #map {
                height: 90%;
            }
        </style>

        <script type="text/javascript">
            var POLYGON = {
                type: 'Polygon',
                coordinates: [[
                    {{#coordinates}}
                        [{{lon}}, {{lat}}],
                    {{/coordinates}}
                ]],
            };

            $(function() {
                var map = L.map('map');

                map.addLayer(new L.StamenTileLayer('toner'));
                map.addLayer(
                    L.geoJson(POLYGON, {
                        style: { color: 'blue' },
                    })
                );
                map.setView([{{center.lat}}, {{center.lon}}], {{zoom}});
            });
        </script>
    </head>

    <body>
        <div id="map"/>
    </body>
</html>
'''

with tempfile.TemporaryDirectory() as temp_dir:
    view_path = os.path.join(temp_dir, 'view.html')
    context = polygon.copy()
    context['coordinates'] = \
            [{'lon': c[0], 'lat': c[1]} for c in context['coordinates'][0]]

    shape = shapely.geometry.Polygon(shell=[
            tuple(c) for c in polygon['coordinates'][0]])
    centroid = shape.centroid

    context['center'] = {'lon': centroid.x, 'lat': centroid.y}
    context['zoom'] = 13
    with open(view_path, 'wt', encoding='utf-8') as f:
        f.write(pystache.render(html_content, context))

    rc = subprocess.call(['open', view_path])
    if rc:
        logging.error('view failed with exit code {}'.format(rc))
        sys.exit(rc)

    input('Press <enter> to exit application\n')
