#!/bin/env node
/*
 * Initialize a Solr instance with data from the St. Louis Police Department
 * via http://www.slmpd.org/Crimereports.shtml.
 *
 * XXX: Need to handle errors that don't have reason fields (e.g. those that
 *      come from somewhere other than CouchDB).
 */

var console = require('console');
var crimedb_common = require('crimedb/common');
var crimedb_geo = require('crimedb/geo');
var csv = require('csv');
var optimist = require('optimist');
var request = require('request');
var strptime = require('micro-strptime').strptime;

/*
 * Import a CSV file into the given database.
 *
 * Note that even if we encounter an error along the way, this function will
 * attempt to import all rows from the CSV file before reporting the error via
 * the callback.
 */
var importCSVFile = function(solrUrl, csvPath, callback) {
    var min = function(a, b) { return a > b ? b : a; };
    var cols = null;
    var insertQueue = [];
    var outstandingDocs = 0;
    var doneParsing = false;
    var callbackErr = null;

    var transformXYCoord = function(idoc, odoc, callback) {
        crimedb_geo.spcsToLatLong(
            2401, idoc['X-Coord'], idoc['Y-Coord'], 'us-ft',
            function(err, gjo) {
                if (err) {
                    callback(err);
                    return;
                }

                /*
                 * This must be formatted such that Solr recognizes it as a (lon, lat)
                 * pair. See http://wiki.apache.org/solr/SolrAdaptersForLuceneSpatial4#Indexing
                 * for details.
                 */
                odoc['location'] =
                    gjo.coordinates[0] + ' ' + gjo.coordinates[1];

                insertQueue.push([odoc, callback]);
                checkFlush();
            }
        );
    };

    var checkFlush = function() {
        var BATCHSIZE = 100;

        /* 
         * Don't flush unless we're over out batch size, or we're done parsing
         * and don't have a ton of docs left. This latter condition ensures
         * that we don't strand docs in the insertQueue after we're done
         * parsing, which would prevent the final callback from running.
         */
        if (insertQueue.length < BATCHSIZE &&
            !doneParsing &&
            outstandingDocs > BATCHSIZE) {
            return;
        }

        var batch = insertQueue.splice(0, insertQueue.length);
        var docs = batch.map(function(v) { return v[0]; });
        var callbacks = batch.map(function(v) { return v[1]; });

        request({
            url: solrUrl + '/update/json',
            qs: {'update.chain': 'id'},
            method: 'POST',
            json: docs},
            function(err, resp, respBody) {
                callbacks.forEach(function(cb) {
                    cb(err);
                });
            }
        );
    };

    csv().from(csvPath)
        .on('record', function(rec) {
            /* Grab the column names from the first record */
            if (!cols) {
                cols = rec;
                return;
            }

            /* Construct our object by mapping column names to values */
            var idoc = {};
            for (var i = 0; i < min(rec.length, cols.length); ++i) {
                idoc[cols[i]] = rec[i].trim();
            }

            /*
             * Perform transformations on our input data to well-kown formats.
             * Do synchronous transforms first, as it's easier.
             */
            var odoc = {};
            odoc['description'] = idoc['Description'];

            odoc['date'] = crimedb_common.formatDateForSolr(
                strptime(idoc['Date Occured'], '%m/%d/%Y %H:%M')
            );

            /* Perform asynchronous transformations */
            ++outstandingDocs;
            transformXYCoord(idoc, odoc, function(err) {
                --outstandingDocs;
                callbackErr = callbackErr || err;

                if (!doneParsing || outstandingDocs > 0) {
                    return;
                }

                request({
                    url: solrUrl + '/update/json',
                    qs: {'commit': 'true'},
                    method: 'POST',
                    json: []},
                    function(err, resp, respBody) {
                        callback(callbackErr || err);
                    }
                );
            });
        }).on('end', function(count) {
            doneParsing = true;
        }).on('error', function(err) {
            callbackErr = callbackErr || err;
            doneParsing = true;
        });
};

/*
 * Import many CSV files into the given database.
 */
var importCSVFiles = function(solrUrl, csvPaths, callback) {
    if (csvPaths.length == 0) {
        callback(null);
        return;
    }

    var csvPath = csvPaths.shift();
    importCSVFile(solrUrl, csvPath, function(err) {
        if (err) {
            console.log('Error importing ' + csvPath);
            callback(err);
        } else {
            console.log('Successfully imported ' + csvPath);
            importCSVFiles(solrUrl, csvPaths, callback);
        }
    });
};

var opts = optimist.options({
    help: {
        alias: 'h',
        boolean: true,
        describe: 'show help'},
    solr: {
        default: 'http://localhost:8080/solr-4.3.0/crime',
        describe: 'the Solr instance to connect to'},
    clear: {
        boolean: true,
        describe: 'clear the database before importing'}})
    .usage('\
usage: $0 <path>\n\
\n\
Imports the file at <path> into the Solr index.\
').wrap(80);
var args = opts.argv;

if (args.h) {
    opts.showHelp(console.log);
    process.exit(0);
}

if (args._.length < 1) {
    console.error('missing required <path> argument\n');
    opts.showHelp();
    process.exit(1);
}

importCSVFiles(args.solr, args._, function(err) {
    if (err) {
        throw err;
    }
});

// vim:filetype=javascript
